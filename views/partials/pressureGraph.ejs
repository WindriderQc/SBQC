<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/0.5.7/chartjs-plugin-annotation.min.js"></script>

<h1>Barometric Pressure</h1>
 <p id="currentPressure">
    <span id="currentReadingsText">Pressure & Temp: N/A</span>
    <span id="pressureDataSourceMessage" style="font-size: 0.8em; margin-left: 10px; color: orange;"></span>
 </p>
<div style="position: relative; width: 1024px; height: 400px; margin-bottom: 20px;">
    <canvas id="pressureChart" style="position: absolute; z-index: 1;" width="1024" height="400"></canvas>
</div>

<div id="pressureControls" style="margin-top: 20px;">
    <label for="pressureLatitude">Latitude:</label>
    <input type="number" id="pressureLatitude" name="pressureLatitude" value="46.8139" step="any">
    <label for="pressureLongitude">Longitude:</label>
    <input type="number" id="pressureLongitude" name="pressureLongitude" value="-71.2082" step="any">
    <label for="pressureDays" style="margin-left: 10px;">Historical Days:</label>
    <select id="pressureDays" name="pressureDays">
        <option value="1">1 Day</option>
        <option value="2" selected>2 Days (48h)</option>
        <option value="3">3 Days</option>
        <option value="4">4 Days</option>
        <option value="5">5 Days</option>
    </select>
    <label for="pressureForecastHours" style="margin-left: 10px;">Forecast Hours:</label>
    <select id="pressureForecastHours" name="pressureForecastHours">
        <option value="12">12 Hours</option>
        <option value="24">24 Hours</option>
        <option value="36">36 Hours</option>
        <option value="48" selected>48 Hours</option>
    </select>
    <button id="refreshPressure" style="margin-left: 10px;">Refresh Data</button>
    <small id="pressureDataRangeMessage" style="margin-left: 10px;">(Displays historical and forecast pressure/temp)</small>
    <div id="averageControls" style="margin-top: 10px;">
        <input type="checkbox" id="showAvgWeek" name="showAvgWeek" checked>
        <label for="showAvgWeek" style="margin-right: 10px;">Avg Week</label>

        <input type="checkbox" id="showAvgMonth" name="showAvgMonth" checked>
        <label for="showAvgMonth" style="margin-right: 10px;">Avg Month</label>

        <input type="checkbox" id="showAvgYear" name="showAvgYear" checked>
        <label for="showAvgYear">Avg Year</label>
    </div>
</div>
<!-- Ensure the pressureDataSourceMessage span is present in the p tag for current readings -->
<script>
    // pressureData and tempData will now be arrays of values for the chart
    // pressureTimes will be the labels (timestamps)
    let pressureValues = [];
    let tempValues = [];
    let chartTimeLabels = [];
    let pressureChartInstance; 
    let currentServerResponse = null;

    async function fetchPressureData(lat, lon, days, forecastHours) { // Removed default values
        // Update data range message at the beginning of the function
        const rangeMessageEl = document.getElementById('pressureDataRangeMessage');
        if (rangeMessageEl) {
            rangeMessageEl.textContent = `(Displays ${days} day(s) historical and ${forecastHours} hours forecast pressure/temp)`;
        }

        let serverResponse; 
        const cacheKey = `pressureData-${lat}-${lon}-${days}`;
        const lastFetchedKey = `lastFetchedPressure-${lat}-${lon}-${days}`;
        const cachedData = localStorage.getItem(cacheKey);
        const lastFetched = localStorage.getItem(lastFetchedKey);

        if (cachedData && moment().diff(moment(lastFetched), 'minutes') < 30) {
            serverResponse = JSON.parse(cachedData);
            console.log(`Fetching cached pressure/temp data for ${days} days (raw):`, serverResponse);
        } else {
            console.log(`Fetching API pressure/temp data for lat: ${lat}, lon: ${lon}, days: ${days}`);
            try {
                const response = await fetch(`/api/pressure?lat=${lat}&lon=${lon}&days=${days}`);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: response.statusText }));
                    console.error('Error fetching pressure/temp:', errorData.error || response.statusText);
                    alert(`Error fetching pressure/temp: ${errorData.error || response.statusText}`);
                    displayPressureChartError(`Failed to load data: ${errorData.error || response.statusText}`);
                    return;
                }
                serverResponse = await response.json();
                localStorage.setItem(cacheKey, JSON.stringify(serverResponse)); // Cache the full response
                localStorage.setItem(lastFetchedKey, moment().toISOString());
            } catch (error) {
                console.error('Network error or JSON parsing error fetching pressure/temp:', error);
                alert('Failed to fetch pressure/temp data. Please check your network connection.');
                displayPressureChartError('Network error or server issue.');
                return;
            }
        }

        currentServerResponse = serverResponse;
        renderPressureChart();
    }

    function renderPressureChart() {
        if (!currentServerResponse) return;

        const serverResponse = currentServerResponse;
        const forecastHours = parseInt(document.getElementById('pressureForecastHours').value, 10);

        const dataSourceMessageEl = document.getElementById('pressureDataSourceMessage');
        if (dataSourceMessageEl) {
            if (serverResponse.data_source === "mock") {
                let reasonMsg = "API issue";
                if (serverResponse.mock_reason === "missing_api_key") {
                    reasonMsg = "Missing API Key";
                } else if (serverResponse.mock_reason === "api_error") {
                    reasonMsg = "API Error";
                }
                dataSourceMessageEl.textContent = ` (Warning: Displaying mock data due to ${reasonMsg})`;
                dataSourceMessageEl.style.color = "orange";
            } else {
                dataSourceMessageEl.textContent = "";
            }
        }

        if (serverResponse && serverResponse.readings && serverResponse.readings.length > 0) {
            const nowUnix = moment().unix();
            const forecastEndTimeUnix = nowUnix + (forecastHours * 60 * 60);

            // Filter readings based on forecastHours
            const filteredReadings = serverResponse.readings.filter(r => {
                if (r.dt <= nowUnix) {
                    return true; // Keep all historical data
                } else {
                    return r.dt <= forecastEndTimeUnix; // Keep forecast data within the selected window
                }
            });

            if (filteredReadings.length === 0) {
                console.log('No data after filtering for forecast hours.');
                displayPressureChartError('No data available for the selected time range.');
                document.getElementById('currentReadingsText').textContent = 'Pressure & Temp: N/A';
                if (dataSourceMessageEl) dataSourceMessageEl.textContent = ''; // Clear warning if it was set
                return;
            }

            pressureValues = filteredReadings.map(r => r.pressure);
            tempValues = filteredReadings.map(r => r.temp);
            chartTimeLabels = filteredReadings.map(r => moment.unix(r.dt).toDate());

            // Update current readings based on the original (or filtered, if it makes sense) serverResponse
            // For simplicity, using the first point of filteredReadings or a point closest to 'now' from filteredReadings
            let closestReading = filteredReadings[0];
            for (const reading of serverResponse.readings) {
                if (reading.dt <= nowUnix) {
                    closestReading = reading;
                } else {
                    if (closestReading.dt > nowUnix) {
                        if (reading.dt < closestReading.dt) closestReading = reading;
                    }
                    break; 
                }
            }

            // Update the specific span for readings text
            document.getElementById('currentReadingsText').textContent =

                `Pressure: ${closestReading.pressure.toFixed(1)} hPa, Temp: ${closestReading.temp.toFixed(1)} 째C (at ${moment.unix(closestReading.dt).format('HH:mm')})`;

            const ctx = document.getElementById('pressureChart').getContext('2d');
            if (pressureChartInstance) {
                pressureChartInstance.destroy();
            }

            // Prepare annotations
            const annotations = [{
                type: 'line',
                mode: 'vertical',
                scaleID: 'x-axis-0',
                value: moment().toDate(),
                borderColor: 'green',
                borderWidth: 2,
                label: {
                    content: 'Now',
                    enabled: true,
                    position: 'top'
                }
            }];

            // Check checkboxes
            const showWeek = document.getElementById('showAvgWeek').checked;
            const showMonth = document.getElementById('showAvgMonth').checked;
            const showYear = document.getElementById('showAvgYear').checked;

            if (serverResponse.averages) {
                if (showWeek && serverResponse.averages.week) {
                    annotations.push({
                        type: 'line',
                        mode: 'horizontal',
                        scaleID: 'y-axis-pressure',
                        value: serverResponse.averages.week,
                        borderColor: 'rgba(255, 159, 64, 0.7)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            content: 'Avg Week: ' + serverResponse.averages.week,
                            enabled: true,
                            position: 'right',
                            backgroundColor: 'rgba(255, 159, 64, 0.7)',
                            fontSize: 10
                        }
                    });
                }
                if (showMonth && serverResponse.averages.month) {
                     annotations.push({
                        type: 'line',
                        mode: 'horizontal',
                        scaleID: 'y-axis-pressure',
                        value: serverResponse.averages.month,
                        borderColor: 'rgba(75, 192, 192, 0.7)',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        label: {
                            content: 'Avg Month: ' + serverResponse.averages.month,
                            enabled: true,
                            position: 'right',
                            backgroundColor: 'rgba(75, 192, 192, 0.7)',
                            fontSize: 10
                        }
                    });
                }
                 if (showYear && serverResponse.averages.year) {
                     annotations.push({
                        type: 'line',
                        mode: 'horizontal',
                        scaleID: 'y-axis-pressure',
                        value: serverResponse.averages.year,
                        borderColor: 'rgba(153, 102, 255, 0.7)',
                        borderWidth: 2,
                        borderDash: [2, 2],
                        label: {
                            content: 'Avg Year: ' + serverResponse.averages.year,
                            enabled: true,
                            position: 'right',
                            backgroundColor: 'rgba(153, 102, 255, 0.7)',
                            fontSize: 10
                        }
                    });
                }
            }

            pressureChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartTimeLabels,
                    datasets: [
                        {
                            label: 'Barometric Pressure (hPa)',
                            data: pressureValues,
                            borderColor: 'blue',
                            borderWidth: 2,
                            pointRadius: 1,
                            fill: false, // No fill for pressure to see temp line better
                            yAxisID: 'y-axis-pressure',
                        },
                        {
                            label: 'Temperature (째C)',
                            data: tempValues,
                            borderColor: 'red',
                            borderWidth: 2,
                            pointRadius: 1,
                            fill: false,
                            yAxisID: 'y-axis-temp',
                        }
                    ]
                },
                options: {
                    responsive: false, // Keep as is from original
                    scales: {
                        xAxes: [{
                            type: 'time',
                            time: { // Time configuration options still live here
                                tooltipFormat: 'ddd D MMM HH:mm',
                                unit: 'hour',
                                displayFormats: { hour: 'MMM D, HH:mm' }
                            },
                            ticks: { // Min, max, callback, autoSkip, etc. go into ticks configuration
                                min: chartTimeLabels.length > 0 ? chartTimeLabels[0] : new Date(), // Fallback, will be empty if no data
                                max: chartTimeLabels.length > 0 ? chartTimeLabels[chartTimeLabels.length - 1] : new Date(), // Fallback
                                autoSkip: true,
                                maxTicksLimit: 20
                            }
                        }],
                        yAxes: [
                            {
                                id: 'y-axis-pressure',
                                type: 'linear',
                                position: 'left',
                                scaleLabel: {
                                    display: true,
                                    labelString: 'Pressure (hPa)'
                                }
                            },
                            {
                                id: 'y-axis-temp',
                                type: 'linear',
                                position: 'right',
                                scaleLabel: {
                                    display: true,
                                    labelString: 'Temperature (째C)'
                                },
                                gridLines: { // Optional: disable grid lines for the second axis if too cluttered
                                    drawOnChartArea: false, 
                                }
                            }
                        ]
                    },
                    tooltips: { // For Chart.js v2.9.4
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(tooltipItem, data) {
                                let label = data.datasets[tooltipItem.datasetIndex].label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += parseFloat(tooltipItem.value).toFixed(1);
                                if (tooltipItem.datasetIndex === 0) label += ' hPa';
                                if (tooltipItem.datasetIndex === 1) label += ' 째C';
                                return label;
                            }
                        }
                    },
                    annotation: {
                        annotations: annotations
                    }
                }
            });
        } else {
            console.log('No pressure/temp data to display or error in data structure.');
            const message = (serverResponse && serverResponse.message) ? serverResponse.message : 'No pressure/temp data available.';
            displayPressureChartError(message);
            // Update specific span and clear data source message
            document.getElementById('currentReadingsText').textContent = 'Pressure & Temp: N/A';
            const dsMessageEl = document.getElementById('pressureDataSourceMessage');
            if (dsMessageEl) dsMessageEl.textContent = '';
        }
    }

    function displayPressureChartError(message) { 
        if (pressureChartInstance) {
            pressureChartInstance.destroy();
            pressureChartInstance = null;
        }
        const ctx = document.getElementById('pressureChart').getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
        ctx.font = "16px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
    }


    // Event listener for the refresh button
    document.getElementById('refreshPressure').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('pressureLatitude').value);
        const lon = parseFloat(document.getElementById('pressureLongitude').value);
        const days = parseInt(document.getElementById('pressureDays').value, 10);
        const forecastHours = parseInt(document.getElementById('pressureForecastHours').value, 10);

        if (isNaN(lat) || isNaN(lon) || isNaN(days) || isNaN(forecastHours)) {
            alert('Please enter valid numbers for latitude, longitude, and select valid historical days and forecast hours.');
            return;
        }
        if (days < 1 || days > 5) {
            alert('Please select a value between 1 and 5 for historical days for pressure.');
            return;
        }
        if (forecastHours < 1 || forecastHours > 48) { // Assuming 48 is max, adjust if options change
            alert('Please select a valid forecast duration (e.g., 12 to 48 hours).');
            return;
        }

        // The range message is now updated inside fetchPressureData
        fetchPressureData(lat, lon, days, forecastHours);
    });

    // Checkbox event listeners
    ['showAvgWeek', 'showAvgMonth', 'showAvgYear'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', renderPressureChart);
    });

    // Initial data fetch on page load
    document.addEventListener('DOMContentLoaded', () => {
        const initialLat = parseFloat(document.getElementById('pressureLatitude').value);
        const initialLon = parseFloat(document.getElementById('pressureLongitude').value);
        const initialDays = parseInt(document.getElementById('pressureDays').value, 10);
        const initialForecastHours = parseInt(document.getElementById('pressureForecastHours').value, 10);

        // The range message is now updated inside fetchPressureData
        fetchPressureData(initialLat, initialLon, initialDays, initialForecastHours);
    });

</script>
