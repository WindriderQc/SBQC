<!DOCTYPE html>
<html lang="en">

<head>
    <%- include('partials/mainHead', { title: 'SBQC ISS Tracker' }) %>
</head>

<body class="fixed-nav sticky-footer bg-light sidenav-toggled" id="page-top">

<%- include('partials/nav') %>

<div class="content-wrapper">
<div class="container-fluid bg-3 text-center">
    <!-- Begin Container -->

    <div class="card mb-3">
        <div class="card-body">
            <div class="row">
                <div class="col">
                    <div>Wind Speed: <span id="wind-speed">N/A</span> m/s</div>
                    <div>Wind Gust: <span id="wind-gust">N/A</span> m/s</div>
                </div>
            </div>
        </div>
    </div>

    <p>
        At location: <span id="summary">N/A</span> with a temperature of <span id="temp">N/A</span>&deg; C. <br>
        Air Quality (<span id="aq_parameter">N/A</span>): <span id="aq_value">N/A</span> <span id="aq_units"></span>
        <small>(Last read on <span id="aq_date">N/A</span>)</small>
    </p>

    <div class="card mb-3">
        <div class="card-body">
            <p>Next ISS pass-by: <span id="iss-passby-time">Calculating...</span></p>
        </div>
    </div>

    <div class="card mb-3">
        <div class="card-header">3D ISS Viewer</div>
        <div class="card-body">
            <div id="sketch-holder" style="display: flex; justify-content: center; align-items: center;">
                <!-- p5.js canvas will be parented here -->
            </div>
        </div>
        <div class="card-footer small text-muted">Press 'S' to save canvas to PNG.</div>
    </div>

    <div class="card mb-3" style="max-width: 1280px; margin: 0 auto;">
        <div class="card-header">Controls & Info</div>
        <div class="card-body">
            <p>ISS Location - Latitude: <span id="isslat">N/A</span>&deg;, Longitude: <span id="isslon">N/A</span>&deg;</p>
            <p>Client Location - Latitude: <span id="clat">N/A</span>&deg;, Longitude: <span id="clon">N/A</span>&deg;</p>
            <p id="default-location-msg" style="font-size: 0.8em; color: #777; display: none;">Using default client location as live geolocation is unavailable or denied.</p>
            
            <div style="padding: 10px; text-align: left; border-top: 1px solid #eee;">
                <strong>Legend (3D View):</strong>
                <div style="margin-top: 5px;">
                    <span style="background-color: orange; display: inline-block; width: 20px; height: 10px; margin-right: 5px; border: 1px solid #555;"></span> Historical ISS Path
                </div>
                 <div style="margin-top: 5px;">
                    <span style="background-color: #00FF00; display: inline-block; width: 20px; height: 10px; margin-right: 5px; border: 1px solid #555;"></span> Predicted ISS Path
                </div>
                <div style="margin-top: 5px;">
                    <span style="background-color: yellow; display: inline-block; width: 10px; height: 10px; margin-right: 5px; border: 1px solid #555; border-radius: 50%;"></span> Default Location (Quebec City)
                </div>
                 <div style="margin-top: 5px;">
                    <span style="background-color: rgba(0,100,255,0.3); display: inline-block; width: 20px; height: 10px; margin-right: 5px; border: 1px solid #555;"></span> Pass-by Detection Radius
                </div>
            </div>

            <div style="padding: 10px; text-align: left; border-top: 1px solid #eee;">
                <div>
                    <label for="pathLengthSlider">Historical Path Length: <span id="pathLengthValue">4200</span> points</label>
                    <input type="range" id="pathLengthSlider" min="100" max="4200" step="100" value="4200" style="width: 100%;">
                </div>
                <div style="margin-top: 10px;">
                    <label for="predictionLengthSlider">Prediction Length: <span id="predictionLengthValue">15</span> min</label>
                    <input type="range" id="predictionLengthSlider" min="5" max="360" step="5" value="15" style="width: 100%;">
                </div>
                <div style="margin-top: 10px;">
                    <label for="passByRadiusSlider">Pass-by Detection Radius: <span id="passByRadiusValue">1000</span> km</label>
                    <input type="range" id="passByRadiusSlider" min="100" max="5000" step="100" value="1000" style="width: 100%;">
                </div>
            </div>
        </div>
        <div class="card-footer small text-muted">
            <a href="https://eyes.nasa.gov/apps/solar-system/#/home" target="_blank" class="btn btn-outline-primary">Explore with NASA Eyes</a>
        </div>
    </div>
    <%# Removed <div id="ip_id"></div> %>
</div>
</div>
</div>

<%- include('partials/footer') %> <%# This should load tools.js %>
<script src="/socket.io/socket.io.js"></script>
<%- include('partials/p5') %>
<%# <script src="/js/tools.js"></script> <!-- REMOVED - Loaded in footer --> %>
<script src="/js/earth3D.js"></script>

<script>
    // Page UI and Socket.IO Logic

    let clientLat = null;
    let clientLon = null;
    
    let pagePredictedIssPathPoints = []; 
    
    let lastPassByCheckTime = 0;
    const PASS_BY_CHECK_INTERVAL = 30000; 
    let PASS_BY_THRESHOLD_KM = 1000; // Used for calculation logic
    let predictionDurationSeconds = 15 * 60; 

    const socket = io();

    socket.on('connect', () => {
        console.log('Connected to server via Socket.IO');
    });

    socket.on('iss', (data) => {
        window.iss = data; 
        
        if (document.getElementById('isslat') && document.getElementById('isslon')) {
            document.getElementById('isslat').textContent = parseFloat(data.latitude).toFixed(2);
            document.getElementById('isslon').textContent = parseFloat(data.longitude).toFixed(2);
        }

        const now = Date.now();
        if (clientLat !== null && clientLon !== null && now - lastPassByCheckTime > PASS_BY_CHECK_INTERVAL) {
            calculateAndDisplayPassBy(); 
            lastPassByCheckTime = now;
        }
    });

    async function fetchWeatherForCoords(lat, lon) {
        if (!lat || !lon) return;
        const url = `/api/weather/${lat},${lon}`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Weather API request failed with status ${response.status}`);
            const data = await response.json();
            document.getElementById('summary').textContent = data.weather.weather[0].description;
            document.getElementById('temp').textContent = data.weather.main.feels_like.toFixed(1);
            if (data.air_quality && data.air_quality.results && data.air_quality.results[0] && data.air_quality.results[0].latest) {
                const air = data.air_quality.results[0];
                document.getElementById('aq_parameter').textContent = air.parameter ? air.parameter.displayName : 'N/A';
                document.getElementById('aq_value').textContent = air.latest.value;
                document.getElementById('aq_units').textContent = air.parameter ? air.parameter.units : '';
                document.getElementById('aq_date').textContent = air.latest.datetime && air.latest.datetime.local ? air.latest.datetime.local : 'N/A';
            } else { document.getElementById('aq_value').textContent = 'NO READING'; }
            const wind = data.weather.wind;
            document.getElementById('wind-speed').textContent = wind.speed;
            document.getElementById('wind-gust').textContent = wind.gust || 'N/A';
        } catch (e) {
            console.error('Error fetching weather data:', e);
            document.getElementById('summary').textContent = 'Error';
            document.getElementById('temp').textContent = 'N/A';
            document.getElementById('aq_value').textContent = 'NO READING';
        }
    }

    async function setDefaultLocationAndFetchWeather() {
        console.log("Using default client location (Quebec City area).");
        clientLat = 46.8139; clientLon = -71.2080; 
        document.getElementById('clat').textContent = clientLat.toFixed(2);
        document.getElementById('clon').textContent = clientLon.toFixed(2);
        document.getElementById('default-location-msg').style.display = 'block';
        await fetchWeatherForCoords(clientLat, clientLon);
    }

    async function updateGeoData() {
        if (typeof Tools === 'undefined' || !Tools.isGeoLocAvailable || !Tools.geoLocate) {
            console.log("Tools.js not available or complete. Using default location.");
            await setDefaultLocationAndFetchWeather(); return;
        }
        if (!Tools.isGeoLocAvailable()) { 
            console.log("Geolocation not available in this browser.");
            await setDefaultLocationAndFetchWeather(); return;
        }
        try {
            console.log("Attempting to get live geolocation...");
            const { coords } = await Tools.geoLocate(); 
            clientLat = coords.latitude; clientLon = coords.longitude;
            console.log("Live geolocation successful:", clientLat, clientLon);
            document.getElementById('default-location-msg').style.display = 'none';
            document.getElementById('clat').textContent = clientLat.toFixed(2);
            document.getElementById('clon').textContent = clientLon.toFixed(2);
            await fetchWeatherForCoords(clientLat, clientLon);
        } catch (e) {
            console.warn('Error getting live geolocation or permission denied:', e.message);
            await setDefaultLocationAndFetchWeather();
        }
    }
    
    function calculateAndDisplayPassBy() {
        const passByStatus = document.getElementById('iss-passby-time');
        let currentIssHistory = [];
        if (window.earth3DSketch && typeof window.earth3DSketch.getInternalIssPathHistory === 'function') {
            currentIssHistory = window.earth3DSketch.getInternalIssPathHistory();
        }
        console.log('[calculateAndDisplayPassBy] Checking sketch history via window.earth3DSketch. Length:', currentIssHistory ? currentIssHistory.length : 'undefined');
        if (clientLat === null || clientLon === null) {
            passByStatus.textContent = 'Waiting for client location...';
            if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath([]); 
            return;
        }
        if (!currentIssHistory || currentIssHistory.length < 2) {
            passByStatus.textContent = 'Insufficient ISS path data...';
            pagePredictedIssPathPoints = []; 
            if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath(pagePredictedIssPathPoints); 
            return;
        }
        let basePath = currentIssHistory; 
        if (typeof Tools === 'undefined' || typeof Tools.haversineDistance !== 'function') { 
            passByStatus.textContent = 'Distance calculation tool not available.';
            if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath([]); 
            return;
        }
        passByStatus.textContent = 'Calculating...';
        const lastPointData = basePath[basePath.length - 1]; const secondLastPointData = basePath[basePath.length - 2];
        const lastPointTimestamp = new Date(lastPointData.timeStamp).getTime(); const secondLastPointTimestamp = new Date(secondLastPointData.timeStamp).getTime();
        if (isNaN(lastPointTimestamp) || isNaN(secondLastPointTimestamp)) {
            passByStatus.textContent = 'Error with timestamp data.';
            if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath([]);
            return;
        }
        const timeDiffSeconds = (lastPointTimestamp - secondLastPointTimestamp) / 1000;
        if (timeDiffSeconds <= 0) {
            passByStatus.textContent = 'Static or invalid ISS data timestamps for speed calculation.';
            if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath([]); 
            return;
        }
        const latSpeed = (lastPointData.lat - secondLastPointData.lat) / timeDiffSeconds; const lonSpeed = (lastPointData.lon - secondLastPointData.lon) / timeDiffSeconds; 
        let minFutureDist = Infinity; let timeOfClosestApproach = null; let tempPredictedPath = []; 
        for (let t = 0; t < predictionDurationSeconds; t += 30) { 
            let futureLat = lastPointData.lat + latSpeed * t; // Changed const to let
            futureLat = Math.max(-52.0, Math.min(52.0, futureLat)); // Added clamping for latitude
            const futureLon = lastPointData.lon + lonSpeed * t;
            const normalizedFutureLon = (futureLon + 540) % 360 - 180; 

            tempPredictedPath.push({ lat: futureLat, lng: normalizedFutureLon }); 

            const dist = Tools.haversineDistance(clientLat, clientLon, futureLat, normalizedFutureLon);
            if (dist < minFutureDist) {
                minFutureDist = dist;
                timeOfClosestApproach = t;
            }
        }

        console.log(`[PassByDebug] minFutureDist: ${minFutureDist.toFixed(2)} km, PASS_BY_THRESHOLD_KM: ${PASS_BY_THRESHOLD_KM} km, timeOfClosestApproach: ${timeOfClosestApproach}s`);

        if (minFutureDist < PASS_BY_THRESHOLD_KM && timeOfClosestApproach !== null) {
            pagePredictedIssPathPoints = tempPredictedPath.filter((pt, idx) => (idx * 30) <= timeOfClosestApproach || minFutureDist < PASS_BY_THRESHOLD_KM);
            console.log(`[PassByDebug] Close pass DETECTED. pagePredictedIssPathPoints length: ${pagePredictedIssPathPoints.length}`);
        } else {
            pagePredictedIssPathPoints = []; 
            console.log(`[PassByDebug] No close pass detected or condition not met. pagePredictedIssPathPoints CLEARED.`);
        }
        
        console.log(`[PassByDebug] Just before calling update3DPredictedPath, pagePredictedIssPathPoints length: ${pagePredictedIssPathPoints.length}`);
        if (pagePredictedIssPathPoints.length > 0) {
            console.log('[PassByDebug] pagePredictedIssPathPoints (first 3):', JSON.stringify(pagePredictedIssPathPoints.slice(0,3)));
        }

        if (window.earth3DSketch && typeof window.earth3DSketch.updatePredictedPath === 'function') window.earth3DSketch.updatePredictedPath(pagePredictedIssPathPoints); 
        if (minFutureDist < PASS_BY_THRESHOLD_KM && timeOfClosestApproach !== null) {
            const approachDate = new Date(Date.now() + timeOfClosestApproach * 1000);
            passByStatus.textContent = `Approx. pass at ${approachDate.toLocaleTimeString()} (distance ~${minFutureDist.toFixed(0)} km).`;
        } else {
            passByStatus.textContent = `No close pass predicted (within ${PASS_BY_THRESHOLD_KM}km and ${predictionDurationSeconds/60}min). Closest ~${minFutureDist.toFixed(0)}km.`;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateGeoData(); 

        const pathLengthSlider = document.getElementById('pathLengthSlider');
        const pathLengthValueSpan = document.getElementById('pathLengthValue');
        const predictionLengthSlider = document.getElementById('predictionLengthSlider');
        const predictionLengthValueSpan = document.getElementById('predictionLengthValue');
        const passByRadiusSlider = document.getElementById('passByRadiusSlider');
        const passByRadiusValueSpan = document.getElementById('passByRadiusValue');

        if (pathLengthSlider && pathLengthValueSpan) {
            pathLengthSlider.addEventListener('input', function() {
                pathLengthValueSpan.textContent = this.value;
                if (window.earth3DSketch && typeof window.earth3DSketch.setMaxHistoryPoints === 'function') {
                    window.earth3DSketch.setMaxHistoryPoints(parseInt(this.value)); 
                }
                calculateAndDisplayPassBy(); 
            });
        }

        if (predictionLengthSlider && predictionLengthValueSpan) {
            predictionLengthSlider.addEventListener('input', function() {
                predictionLengthValueSpan.textContent = this.value;
                predictionDurationSeconds = parseInt(this.value) * 60;
                calculateAndDisplayPassBy();
            });
        }

        if (passByRadiusSlider && passByRadiusValueSpan) {
            passByRadiusSlider.addEventListener('input', function() {
                passByRadiusValueSpan.textContent = this.value;
                PASS_BY_THRESHOLD_KM = parseInt(this.value); 
                if (window.earth3DSketch && typeof window.earth3DSketch.setSketchPassByRadiusKM === 'function') {
                    window.earth3DSketch.setSketchPassByRadiusKM(parseInt(this.value)); 
                }
                calculateAndDisplayPassBy(); 
            });
        }
    });
</script>

</body>
</html>
