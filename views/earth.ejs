<!DOCTYPE html>
<html lang="en">

<head>
        <%- include('partials/mainHead', { title: 'SBQC ' }) %>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"    integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="    crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"    integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="    crossorigin=""></script>
        <style>
            .arrow {
                width: 0;
                height: 0;
                border-left: 10px solid transparent;
                border-right: 10px solid transparent;
                border-bottom: 20px solid black;
                transform-origin: center;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(0deg);
            }

            .wind-container {
                position: relative;
                width: 100px;
                height: 100px;
                margin: 0 auto;
            }

            .cardinal-points {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }

            .cardinal-points .north {
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
            }

            .cardinal-points .east {
                position: absolute;
                top: 50%;
                right: 0;
                transform: translateY(-50%);
            }

            .cardinal-points .south {
                position: absolute;
                bottom: 0;
                left: 50%;
                transform: translateX(-50%);
            }

            .cardinal-points .west {
                position: absolute;
                top: 50%;
                left: 0;
                transform: translateY(-50%);
            }
            </style>

    </head>


<body class="fixed-nav sticky-footer bg-light sidenav-toggled" id="page-top">

<%- include('partials/nav') %>

<div class="content-wrapper">
<div class="container-fluid bg-3 text-center">
<!-- Begin Container  -->

<div class="card mb-3">
    <div class="card-body">
        <div class="row">
            <div class="col-6">
                <div class="wind-container">
                    <div id="wind-arrow" class="arrow"></div>
                    <div class="cardinal-points">
                        <div class="north">N</div>
                        <div class="east">E</div>
                        <div class="south">S</div>
                        <div class="west">W</div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div>Speed: <span id="wind-speed"></span> m/s</div>
                <div>Gust: <span id="wind-gust"></span> m/s</div>
            </div>
        </div>
    </div>
</div>

        <p>
            At location: <span id="summary"></span> with a temperature of <span id="temp"></span>&deg; C. <br>
            Concentration of particulate matter - (<span id="aq_parameter"></span>) <span id="aq_value"></span> <span id="aq_units"></span> <br>
            <small> Last read on <span id="aq_date"></span></small>
        </p>

        <div class="card mb-3">
            <div class="card-body">
                <p>Next ISS pass-by: <span id="iss-passby-time">Calculating...</span></p>
            </div>
        </div>

        <div class="card mb-3">
                <div class="card-title">3D Viewer</div>
                <div class="card-body" >
                        <div id="sketch-holder">
                </div>
                <div class="card-footer small text-muted">Press 's' to save canvas to png  </div>
        </div>

        <div class="card mb-3" style="max-width: 1280px; margin: 0 auto;">
                <div class="card-body" >
                        <p>ISS location -  lat: <span id="isslat"></span>&deg; lon: <span id="isslon"></span>&deg; </p>
                        <p>Client location -  lat: <span id="clat"></span>&deg; lon: <span id="clon"></span>&deg;</span> </p>
                        <p id="default-location-msg" style="font-size: 0.8em; color: #777; display: none;">Using default location as live geolocation is unavailable.</p>
                        <div id='issMap' style="height:720px;"></div>
                        <div style="padding: 10px; text-align: left; border-top: 1px solid #eee;">
                            <strong>Legend:</strong>
                            <div style="margin-top: 5px;">
                                <span style="background-color: blue; display: inline-block; width: 20px; height: 10px; margin-right: 5px; border: 1px solid #555;"></span> Live ISS Path (WebSocket)
                            </div>
                            <div style="margin-top: 5px;">
                                <span style="background-color: orange; display: inline-block; width: 20px; height: 10px; margin-right: 5px; border: 1px solid #555;"></span> Historical ISS Path (Database)
                            </div>
                        </div>
                        <div style="padding: 10px; text-align: left; border-top: 1px solid #eee;">
                            <!-- Existing Path Length Slider -->
                            <div>
                                <label for="pathLengthSlider">Path Length: <span id="pathLengthValue">4200</span> points</label>
                                <input type="range" id="pathLengthSlider" min="100" max="4200" step="100" value="4200" style="width: 100%;">
                            </div>

                            <!-- New Prediction Length Slider -->
                            <div style="margin-top: 10px;">
                                <label for="predictionLengthSlider">Prediction Length: <span id="predictionLengthValue">15</span> min</label>
                                <input type="range" id="predictionLengthSlider" min="5" max="360" step="5" value="15" style="width: 100%;">
                            </div>

                            <!-- New Pass-by Radius Slider -->
                            <div style="margin-top: 10px;">
                                <label for="passByRadiusSlider">Pass-by Radius: <span id="passByRadiusValue">1000</span> km</label>
                                <input type="range" id="passByRadiusSlider" min="100" max="5000" step="100" value="1000" style="width: 100%;">
                            </div>
                        </div>
                </div>
                <div class="card-footer small text-muted"> <a href="https://eyes.nasa.gov/apps/solar-system/#/home" target="_blank" class="btn btn-outline-primary">Explore with NASA Eyes</a> </div>
        </div>

<!-- End Container  -->
</div>
</div>
</div>
<div id="ip_id"></div>

<%- include('partials/footer') %>
<%- include('partials/p5') %>

<script src="/js/earth3D.js"></script>

<script>

let iss;   // International Space Station location
let clientLat = null;
let clientLon = null;

// For 2D path
let issPathHistory = [];
let MAX_2D_HISTORY_POINTS = 4200; // Changed from const to let
let issPathPolyline = null; // Live ISS path
let historicalIssPathSegments = []; // Historical ISS path from initial load, now stores array of segments
let mymap; // Declare mymap globally

// For Predicted Path
let predictedIssPathPoints = []; // This array remains for 3D view
// let predictedIssPathPolyline = null; // Removed for 2D map

// For pass-by estimation
let lastPassByCheckTime = 0;
const PASS_BY_CHECK_INTERVAL = 30000; // 30 seconds
let PASS_BY_THRESHOLD_KM = 1000; // Max distance for a "close" pass - Changed to let
let predictionDurationSeconds = 15 * 60; // Default 15 minutes in seconds

let socket = io();

socket.on('connect', () => {
    console.log('Connected to server');
});

socket.on('iss', (data) => {
    iss = data; // iss is used by earth3D.js globally

    issPathHistory.push({lat: iss.latitude, lng: iss.longitude, timestamp: Date.now()});
    if (issPathHistory.length > MAX_2D_HISTORY_POINTS) {
        issPathHistory.shift();
    }
    updateIssOnMap(iss.latitude, iss.longitude); // This will also update predicted path display

    const now = Date.now();
    if (clientLat !== null && clientLon !== null && now - lastPassByCheckTime > PASS_BY_CHECK_INTERVAL) {
        calculateAndDisplayPassBy();
        // updateIssOnMap() is called above, which will refresh the predicted path if it changed
        lastPassByCheckTime = now;
    }
});

function setMap() {
    mymap = L.map('issMap').setView([0, 0], 1);
    const attribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
    const tileUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    const tiles = L.tileLayer(tileUrl, { attribution });
    tiles.addTo(mymap);

    const issIcon = L.icon({
        iconUrl: 'img/iss.png',
        iconSize: [50, 32],
        iconAnchor: [25, 16]
    });

    let clientMarkerInstance = L.marker([0, 0]).addTo(mymap);
    let issMarkerInstance = L.marker([0, 0], { icon: issIcon }).addTo(mymap);

    mymap.on('zoomend', function() {
        const zoom = mymap.getZoom() + 1;
        const w = 50 * zoom;
        const h = 32 * zoom;
        issIcon.options.iconSize = [w, h];
        issIcon.options.iconAnchor = [w / 2, h / 2];
        mymap.removeLayer(issMarkerInstance);
        let latlng = issMarkerInstance.getLatLng();
        issMarkerInstance = L.marker([0,0], {icon: issIcon}).addTo(mymap);
        issMarkerInstance.setLatLng(latlng);
    });

    window.clientMarker = clientMarkerInstance;
    window.issMarker = issMarkerInstance;

    return { mymap_local: mymap, clientMarker_local: clientMarkerInstance, issMarker_local: issMarkerInstance };
}

const mapSetUp = setMap();

function setClientMarker(lat, lon) {
    if (window.clientMarker) {
        window.clientMarker.setLatLng([lat, lon]);
        if (mymap) {
            mymap.setView([lat, lon], 5);
        }
    }
    clientLat = lat;
    clientLon = lon;
}

async function fetchWeatherForCoords(lat, lon) {
    const url =`api/weather/${lat},${lon}`;
    try {
        const response = await fetch(url);
        const data = await response.json();

        document.getElementById('summary').textContent = data.weather.weather[0].description;
        document.getElementById('temp').textContent =  data.weather.main.feels_like;
        if (data.air_quality && data.air_quality.results && data.air_quality.results[0]) {
            const air = data.air_quality.results[0];
            document.getElementById('aq_parameter').textContent = air.parameter.displayName;
            document.getElementById('aq_value').textContent = air.latest.value;
            document.getElementById('aq_units').textContent = air.parameter.units;
            document.getElementById('aq_date').textContent = air.latest.datetime.local;
        } else {
             document.getElementById('aq_value').textContent = 'NO READING';
        }
        const wind = data.weather.wind;
        document.getElementById('wind-speed').textContent = wind.speed;
        document.getElementById('wind-gust').textContent = wind.gust;
        document.getElementById('wind-arrow').style.transform = `rotate(${wind.deg}deg)`;

    } catch (e) {
        Tools.cliError(e);
        document.getElementById('aq_value').textContent = 'NO READING';
    }
}

async function setDefaultLocationAndFetchWeather() {
    console.log("Using default client location.");
    clientLat = 46.82;
    clientLon = -71.30;

    document.getElementById('clat').textContent = clientLat.toFixed(2);
    document.getElementById('clon').textContent = clientLon.toFixed(2);
    document.getElementById('default-location-msg').style.display = 'block';

    setClientMarker(clientLat, clientLon);
    await fetchWeatherForCoords(clientLat, clientLon);
}

async function updateGeoData() {
    try {
        console.log("Attempting to get live geolocation...");
        const {coords} = await Tools.geoLocate();
        clientLat = coords.latitude;
        clientLon = coords.longitude;
        console.log("Live geolocation successful:", clientLat, clientLon);
        document.getElementById('default-location-msg').style.display = 'none';

        document.getElementById('clat').textContent = clientLat.toFixed(2);
        document.getElementById('clon').textContent = clientLon.toFixed(2);

        setClientMarker(clientLat, clientLon);
        await fetchWeatherForCoords(clientLat, clientLon);

    } catch(e) {
        console.warn('Error getting live geolocation or permission denied:', e.message);
        alert('Live geolocation failed. Using default location (Quebec City area). Error: '+e.message);
        await setDefaultLocationAndFetchWeather();
    }
}

if (Tools.isGeoLocAvailable()) {
    updateGeoData();
} else {
    console.log("Geolocation not available in this browser, using default location.");
    setDefaultLocationAndFetchWeather();
}

let firstTime = true;

function redrawLiveIssPath() {
    if (issPathPolyline && mymap) {
        mymap.removeLayer(issPathPolyline);
    }
    const latLngs = issPathHistory.map(p => [p.lat, p.lng]);
    if (latLngs.length > 1 && mymap) {
        issPathPolyline = L.polyline(latLngs, { color: 'blue', weight: 5 }).addTo(mymap);
    }
}

async function updateIssOnMap(lat, lon) {
    if (window.issMarker) {
         window.issMarker.setLatLng([lat, lon]);
    } else {
        console.warn("ISS marker not initialized for updateIssOnMap");
        return;
    }

    if (firstTime && mymap) {
        if (clientLat === null) {
             mymap.setView([lat, lon], 2);
        }
        firstTime = false;
    }

    document.getElementById('isslat').textContent = parseFloat(lat).toFixed(2);
    document.getElementById('isslon').textContent = parseFloat(lon).toFixed(2);

    redrawLiveIssPath(); // Call the new function for the live path

    // Removed predicted path drawing logic from 2D map
    // The data in predictedIssPathPoints is still calculated by calculateAndDisplayPassBy()
    // and will be used by the 3D visualization if needed.
}

function displayHistoricalDataOn2DMap(historicalPoints) {
    console.log('[Historical 2D Path] Drawing historical data. Points received:', historicalPoints ? historicalPoints.length : 0);

    // Clear previous segments
    if (mymap && historicalIssPathSegments && historicalIssPathSegments.length > 0) {
        historicalIssPathSegments.forEach(segment => mymap.removeLayer(segment));
    }
    historicalIssPathSegments = [];

    if (!historicalPoints || historicalPoints.length < 2) {
        console.log('[Historical 2D Path] Not enough historical points to draw.');
        return;
    }

    let currentSegmentLatLngs = [];
    // Assuming historicalPoints are already sorted by timestamp ASC by earth3D.js
    // The points in historicalPoints are like {lat: ..., lon: ...}

    const MAX_ALLOWED_SEGMENT_JUMP_KM = 500; // Max distance between points in a single segment

    let prevPoint = historicalPoints[0];
    currentSegmentLatLngs.push([prevPoint.lat, prevPoint.lon]);

    for (let i = 1; i < historicalPoints.length; i++) {
        const currentPoint = historicalPoints[i];
        const currentLatLng = [currentPoint.lat, currentPoint.lon];

        const distanceKm = Tools.haversineDistance(prevPoint.lat, prevPoint.lon, currentPoint.lat, currentPoint.lon);

        // Check for longitude wrap OR excessive distance jump
        if (Math.abs(currentPoint.lon - prevPoint.lon) > 180 || distanceKm > MAX_ALLOWED_SEGMENT_JUMP_KM) {
            if (currentSegmentLatLngs.length > 1 && mymap) {
                const segment = L.polyline(currentSegmentLatLngs, { color: 'orange', weight: 3 }).addTo(mymap);
                historicalIssPathSegments.push(segment);
                console.log(`[Historical 2D Path] Segment drawn due to wrap/jump. Points: ${currentSegmentLatLngs.length}. Reason: lon_diff=${Math.abs(currentPoint.lon - prevPoint.lon).toFixed(2)}, dist_km=${distanceKm.toFixed(2)}`);
            }
            currentSegmentLatLngs = []; // Start a new segment
        }
        currentSegmentLatLngs.push(currentLatLng);
        prevPoint = currentPoint;
    }

    // Draw the last or only segment
    if (currentSegmentLatLngs.length > 1 && mymap) {
        const segment = L.polyline(currentSegmentLatLngs, { color: 'orange', weight: 3 }).addTo(mymap);
        historicalIssPathSegments.push(segment);
    }

    if (historicalIssPathSegments.length > 0) {
        console.log(`[Historical 2D Path] Historical ISS path drawn on 2D map in ${historicalIssPathSegments.length} segment(s).`);
    } else if (historicalPoints.length > 0) {
        console.log('[Historical 2D Path] Path had points but no drawable segments (e.g., all single points after potential splits).');
    }
}

function calculateAndDisplayPassBy() {
    const passByStatus = document.getElementById('iss-passby-time');
    console.log('[PassByDebug] calculateAndDisplayPassBy called.');

    if (!clientLat || !clientLon) {
        passByStatus.textContent = 'Waiting for client location...';
        predictedIssPathPoints = [];
        if (typeof window.update3DPredictedPath === 'function') window.update3DPredictedPath(predictedIssPathPoints);
        // Conditional map update based on available data
        if (window.issMarker && typeof iss !== 'undefined' && iss) updateIssOnMap(iss.latitude, iss.longitude);
        else if (issPathHistory.length > 0) updateIssOnMap(issPathHistory[issPathHistory.length-1].lat, issPathHistory[issPathHistory.length-1].lng);
        console.log('[PassByDebug] Returning: Client location not available.');
        return;
    }

    let basePathForPrediction = issPathHistory; // Default to live data
    let usingHistoricalDataForPrediction = false;

    if (issPathHistory.length < 2) {
        console.log('[PassByDebug] Live ISS path history too short, attempting to use historical data for prediction.');
        if (typeof window.internalIssPathHistory !== 'undefined' && window.internalIssPathHistory.length >= 2) {
            basePathForPrediction = window.internalIssPathHistory;
            usingHistoricalDataForPrediction = true;
            console.log('[PassByDebug] Using historical data for prediction. Points:', basePathForPrediction.length);
        } else {
            console.log('[PassByDebug] Historical data also too short or unavailable for prediction.');
            passByStatus.textContent = 'Insufficient ISS path data (live or historical)...';
            predictedIssPathPoints = [];
            if (typeof window.update3DPredictedPath === 'function') {
                 window.update3DPredictedPath(predictedIssPathPoints);
            }
            if (window.issMarker && typeof iss !== 'undefined' && iss) updateIssOnMap(iss.latitude, iss.longitude);
            else if (issPathHistory.length > 0) updateIssOnMap(issPathHistory[issPathHistory.length-1].lat, issPathHistory[issPathHistory.length-1].lng);
            return;
        }
    } else {
        console.log('[PassByDebug] Using live ISS path history for prediction. Points:', basePathForPrediction.length);
    }

    if (typeof Tools.haversineDistance !== 'function') {
        passByStatus.textContent = 'Distance calculation tool not available.';
        predictedIssPathPoints = [];
        if (typeof window.update3DPredictedPath === 'function') window.update3DPredictedPath(predictedIssPathPoints);
        console.error('[PassByDebug] Returning: Tools.haversineDistance is not a function.');
        return;
    }

    passByStatus.textContent = 'Calculating...';

    let lastPoint, secondLastPoint, timeDiffSeconds;
    let lastPointData, secondLastPointData; // To hold raw points from basePath

    if (usingHistoricalDataForPrediction) {
        console.log('[PassByDebug] Using historical data for point extraction.');
        secondLastPointData = basePathForPrediction[basePathForPrediction.length - 2];
        lastPointData = basePathForPrediction[basePathForPrediction.length - 1];

        // Adapt structure for consistency and use .lon for lng
        // Convert ISO timestamp string to milliseconds
        lastPoint = {
            lat: lastPointData.lat,
            lng: lastPointData.lon,
            timestamp: new Date(lastPointData.timeStamp).getTime()
        };
        secondLastPoint = {
            lat: secondLastPointData.lat,
            lng: secondLastPointData.lon,
            timestamp: new Date(secondLastPointData.timeStamp).getTime()
        };

        timeDiffSeconds = (lastPoint.timestamp - secondLastPoint.timestamp) / 1000;
        console.log(`[PassByDebug] Historical data timeDiffSeconds: ${timeDiffSeconds}s (from actual timestamps)`);

    } else { // Using live issPathHistory
        console.log('[PassByDebug] Using live data for point extraction.');
        lastPointData = basePathForPrediction[basePathForPrediction.length - 1]; // Already has .lat, .lng, .timestamp
        secondLastPointData = basePathForPrediction[basePathForPrediction.length - 2];
        lastPoint = lastPointData;
        secondLastPoint = secondLastPointData;
        timeDiffSeconds = (lastPoint.timestamp - secondLastPoint.timestamp) / 1000;
    }
    console.log('[PassByDebug PredictCalc] lastPoint:', JSON.stringify(lastPoint), 'secondLastPoint:', JSON.stringify(secondLastPoint), 'timeDiffSeconds:', timeDiffSeconds);

    if (timeDiffSeconds <= 0) {
        passByStatus.textContent = 'Static or invalid ISS data timestamps for speed calculation.';
        predictedIssPathPoints = [];
        if (typeof window.update3DPredictedPath === 'function') window.update3DPredictedPath(predictedIssPathPoints);
        console.log('[PassByDebug] Returning: Time difference issue for speed calculation.');
        // updateIssOnMap might not be helpful here as path is not changing.
        return;
    }

    const latSpeed = (lastPoint.lat - secondLastPoint.lat) / timeDiffSeconds;
    const lonSpeed = (lastPoint.lng - secondLastPoint.lng) / timeDiffSeconds; // Ensure .lng is used
    console.log('[PassByDebug PredictCalc] latSpeed:', latSpeed, 'lonSpeed:', lonSpeed);

    let minFutureDist = Infinity;
    let timeOfClosestApproach = null;
    let tempPredictedPath = [];
    predictedIssPathPoints = []; // Clear global predicted path at start of this calculation run

    // console.log('[PassByDebug] Starting extrapolation loop for predicted path...');
    for (let t = 0; t < predictionDurationSeconds; t += 30) { // Use dynamic prediction duration
        const futureLat = lastPoint.lat + latSpeed * t;
        const futureLon = lastPoint.lng + lonSpeed * t;
        const normalizedFutureLon = (futureLon + 540) % 360 - 180;

        tempPredictedPath.push({lat: futureLat, lng: normalizedFutureLon});

        const dist = Tools.haversineDistance(clientLat, clientLon, futureLat, normalizedFutureLon);
        if (dist < minFutureDist) {
            minFutureDist = dist;
            timeOfClosestApproach = t;
            if (minFutureDist < PASS_BY_THRESHOLD_KM) {
                 predictedIssPathPoints = tempPredictedPath.slice(0, tempPredictedPath.length);
            }
        }
    }

    if (!(minFutureDist < PASS_BY_THRESHOLD_KM && timeOfClosestApproach !== null)) {
        predictedIssPathPoints = [];
    }

    console.log(`[PassByDebug PredictCalc] Populated predictedIssPathPoints. Length: ${predictedIssPathPoints.length}`);
    if (predictedIssPathPoints.length > 0) {
        console.log('[PassByDebug PredictCalc] First 3 predicted points:', JSON.stringify(predictedIssPathPoints.slice(0, 3)));
        if (predictedIssPathPoints.length > 3) {
            console.log('[PassByDebug PredictCalc] Last 3 predicted points:', JSON.stringify(predictedIssPathPoints.slice(-3)));
        }
    }
    // Note: window.update3DPredictedPath is called by the slider event listeners after this function completes.

    if (minFutureDist < PASS_BY_THRESHOLD_KM && timeOfClosestApproach !== null) {
        const approachDate = new Date(Date.now() + timeOfClosestApproach * 1000);
        passByStatus.textContent = `Approx. pass at ${approachDate.toLocaleTimeString()} (distance ~${minFutureDist.toFixed(0)} km).`;
    } else {
        passByStatus.textContent = `No close pass predicted soon (closest ~${minFutureDist.toFixed(0)}km).`;
    }

    if (iss && typeof iss.latitude !== 'undefined') {
         updateIssOnMap(iss.latitude, iss.longitude);
    } else if (issPathHistory.length > 0) {
        const lastKnownIss = issPathHistory[issPathHistory.length -1];
        updateIssOnMap(lastKnownIss.lat, lastKnownIss.lng);
    }
}

async function getUserInfo() {
    const info = await Tools.ipLookUp();
    document.getElementById('ip_id').innerHTML =  "<pre>"+JSON.stringify(info,null, '\t') +"</pre>";
}
getUserInfo();

//setTimeout(() => {
//    console.log('[PassByDebug] Initial timeout for calculateAndDisplayPassBy.');
//    if (clientLat !== null && clientLon !== null && issPathHistory.length > 1) {
//        calculateAndDisplayPassBy();
//    } else {
//        console.log('[PassByDebug] Conditions not met for initial pass-by calculation.');
//         document.getElementById('iss-passby-time').textContent = 'Waiting for initial data...';
//     }
// }, 5000); // Commented out/Removed: Initial call is now triggered by onHistoricalDataReadyForPrediction

function onHistoricalDataReadyForPrediction() {
    console.log('[earth.ejs] onHistoricalDataReadyForPrediction called, now calculating initial pass-by and prediction.');
    calculateAndDisplayPassBy();
}
// Make it available on the window object
window.onHistoricalDataReadyForPrediction = onHistoricalDataReadyForPrediction;


const pathLengthSlider = document.getElementById('pathLengthSlider');
const pathLengthValueSpan = document.getElementById('pathLengthValue');

if (pathLengthSlider && pathLengthValueSpan) {
    pathLengthSlider.addEventListener('input', function() {
        MAX_2D_HISTORY_POINTS = parseInt(this.value);
        pathLengthValueSpan.textContent = this.value;

        // Trim issPathHistory (live data)
        while (issPathHistory.length > MAX_2D_HISTORY_POINTS) {
            issPathHistory.shift();
        }
        redrawLiveIssPath(); // Redraw the live path with the new limit

        // Update 3D path length (this will trim internalIssPathHistory in earth3D.js)
        if (typeof window.set3DMaxHistoryPoints === 'function') {
            window.set3DMaxHistoryPoints(MAX_2D_HISTORY_POINTS);
        } else {
            console.warn('[2D Slider] set3DMaxHistoryPoints function not found on window.');
        }

        // Redraw historical 2D path (orange line) using the potentially updated internalIssPathHistory
        if (typeof window.displayHistoricalDataOn2DMap === 'function' && typeof window.internalIssPathHistory !== 'undefined') {
            window.displayHistoricalDataOn2DMap(window.internalIssPathHistory);
        } else {
            console.warn('[2D Slider] displayHistoricalDataOn2DMap or window.internalIssPathHistory not available for redraw.');
        }
        console.log(`Slider changed: Path length for 2D live, 2D historical, and 3D view set to ${MAX_2D_HISTORY_POINTS}`);
    });
}
// Event listener for Prediction Length Slider
const predictionLengthSlider = document.getElementById('predictionLengthSlider');
const predictionLengthValueSpan = document.getElementById('predictionLengthValue');

if (predictionLengthSlider && predictionLengthValueSpan) {
    predictionLengthSlider.addEventListener('input', function() {
        predictionDurationSeconds = parseInt(this.value) * 60;
        predictionLengthValueSpan.textContent = this.value;

        calculateAndDisplayPassBy(); // Recalculate pass-by and prediction points

        // Call to update 3D predicted path (function to be implemented in earth3D.js later)
        if (typeof window.update3DPredictedPath === 'function') {
            window.update3DPredictedPath(predictedIssPathPoints);
        } else {
            console.warn('[Prediction Slider] update3DPredictedPath function not found on window.');
        }
        console.log(`Prediction length slider changed: duration is now ${this.value} minutes (${predictionDurationSeconds}s).`);
    });
}

// Event listener for Pass-by Radius Slider
const passByRadiusSlider = document.getElementById('passByRadiusSlider');
const passByRadiusValueSpan = document.getElementById('passByRadiusValue');

if (passByRadiusSlider && passByRadiusValueSpan) {
    passByRadiusSlider.addEventListener('input', function() {
        PASS_BY_THRESHOLD_KM = parseInt(this.value);
        passByRadiusValueSpan.textContent = this.value;

        calculateAndDisplayPassBy(); // Recalculate pass-by info and prediction points

        // The predicted path points might change if the pass-by threshold affects how many are stored/considered.
        // So, also call update3DPredictedPath here.
        if (typeof window.update3DPredictedPath === 'function') {
            window.update3DPredictedPath(predictedIssPathPoints);
        } else {
            console.warn('[Radius Slider] update3DPredictedPath function not found on window.');
        }
        console.log(`Pass-by radius slider changed: threshold is now ${PASS_BY_THRESHOLD_KM} km.`);
    });
}
</script>

</body>
</html>
